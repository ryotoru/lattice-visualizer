{"version":3,"sources":["LatticeVisualizer.js","App.js","index.js"],"names":["LatticeVisualizer","dimension","setDimension","useState","basis","setBasis","sumLimit","setSumLimit","shadeParallelepiped","setShadeParallelepiped","parallelepipedMesh","setParallelepipedMesh","canvasRef","useRef","sceneRef","THREE","generateLatticePoints","useMemo","points","range","Array","from","length","_","i","coefficients","_len","arguments","arrays","_key","reduce","acc","array","flatMap","x","map","y","cartesianProduct","fill","limitedCoefficients","slice","coeff","point","j","push","projectTo3D","z","render3DLattice","isProjected","canvas","current","scene","clear","camera","clientWidth","clientHeight","renderer","setSize","geometry","positions","Float32Array","flat","setAttribute","material","color","size","pointCloud","add","axesHelper","position","controls","OrbitControls","domElement","animate","requestAnimationFrame","update","render","useEffect","console","warn","render2DLattice","svg","d3","selectAll","remove","width","attr","xExtent","d","yExtent","xScale","domain","yScale","height","data","enter","append","initializeBasis","dim","newBasis","_jsxs","children","_jsx","type","min","max","value","onChange","e","newDimension","parseInt","target","alert","vector","handleBasisChange","row","rowIndex","col","colIndex","parseFloat","style","marginRight","onClick","handleShadeParallelepiped","shadeRandomParallelepiped","randomOffsets","Math","floor","random","parallelepipedVertices","vertex","k","parallelepipedGeometry","parallelepipedMaterial","opacity","transparent","newParallelepipedMesh","handleUnshadeParallelepiped","ref","App","className","ReactDOM","createRoot","document","getElementById","React","StrictMode"],"mappings":"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","file":"static/js/main.1ed14017.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef, useMemo } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport * as d3 from 'd3';\n\nconst MAX_POINTS = 50000; // Adjusted maximum number of points to be generated\n\nconst LatticeVisualizer = () => {\n  const [dimension, setDimension] = useState(2);\n  const [basis, setBasis] = useState([\n    [1, 0],\n    [0, 1]\n  ]);\n  const [sumLimit, setSumLimit] = useState(5);\n  const [shadeParallelepiped, setShadeParallelepiped] = useState(false);\n  const [parallelepipedMesh, setParallelepipedMesh] = useState(null);\n  const canvasRef = useRef(null);\n  const sceneRef = useRef(new THREE.Scene());\n\n  const generateLatticePoints = useMemo(() => {\n    const points = [];\n\n    const range = Array.from({ length: 2 * sumLimit + 1 }, (_, i) => i - sumLimit);\n\n    const cartesianProduct = (...arrays) => arrays.reduce((acc, array) => acc.flatMap(x => array.map(y => [...x, y])), [[]]);\n\n    const coefficients = cartesianProduct(...Array(dimension).fill(range));\n\n    const limitedCoefficients = coefficients.slice(0, MAX_POINTS);\n\n    for (const coeff of limitedCoefficients) {\n      const point = new Array(dimension).fill(0);\n      for (let i = 0; i < dimension; i++) {\n        for (let j = 0; j < dimension; j++) {\n          point[j] += coeff[i] * basis[i][j];\n        }\n      }\n      points.push(point);\n    }\n\n    return points;\n  }, [dimension, basis, sumLimit]);\n\n  const projectTo3D = useMemo(() => points => {\n    return points.map(point => {\n      const [x, y, z] = point;\n      return [x || 0, y || 0, z || 0];\n    });\n  }, []);\n\n  const render2DLattice = () => {\n    const svg = d3.select(canvasRef.current);\n    svg.selectAll(\"*\").remove();\n\n    const width = 1024;\n    const height = 768;\n    const margin = 20;\n\n    svg.attr(\"width\", width).attr(\"height\", height);\n\n    const points = generateLatticePoints;\n\n    const xExtent = d3.extent(points, d => d[0]);\n    const yExtent = d3.extent(points, d => d[1]);\n\n    const xScale = d3.scaleLinear()\n      .domain([xExtent[0], xExtent[1]])\n      .range([margin, width - margin]);\n\n    const yScale = d3.scaleLinear()\n      .domain([yExtent[0], yExtent[1]])\n      .range([height - margin, margin]);\n\n    svg.selectAll(\"circle\")\n      .data(points)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", d => xScale(d[0]))\n      .attr(\"cy\", d => yScale(d[1]))\n      .attr(\"r\", 3)\n      .attr(\"fill\", \"red\");\n\n    svg.append(\"line\")\n      .attr(\"x1\", xScale(0))\n      .attr(\"y1\", 0)\n      .attr(\"x2\", xScale(0))\n      .attr(\"y2\", height)\n      .attr(\"stroke\", \"black\");\n\n    svg.append(\"line\")\n      .attr(\"x1\", 0)\n      .attr(\"y1\", yScale(0))\n      .attr(\"x2\", width)\n      .attr(\"y2\", yScale(0))\n      .attr(\"stroke\", \"black\");\n  };\n\n  const render3DLattice = (isProjected) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const scene = sceneRef.current;\n    scene.clear(); \n\n    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);\n    const renderer = new THREE.WebGLRenderer({ canvas });\n\n    renderer.setSize(1024, 768);\n\n    let points = generateLatticePoints;\n    if (isProjected) {\n      points = projectTo3D(points);\n    }\n\n    const geometry = new THREE.BufferGeometry();\n    const positions = new Float32Array(points.flat());\n    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n    const material = new THREE.PointsMaterial({ color: 0xff0000, size: 0.1 });\n    const pointCloud = new THREE.Points(geometry, material);\n    scene.add(pointCloud);\n\n    const axesHelper = new THREE.AxesHelper(5);\n    scene.add(axesHelper);\n\n    camera.position.z = 10;\n\n    const controls = new OrbitControls(camera, renderer.domElement);\n\n    const animate = () => {\n      requestAnimationFrame(animate);\n      controls.update();\n      renderer.render(scene, camera);\n    };\n\n    animate();\n  };\n\n  useEffect(() => {\n    if (dimension > 3) {\n      console.warn(\"Visualization only supports up to 3 dimensions.\");\n      render3DLattice(true); \n    } else if (dimension === 2) {\n      render2DLattice();\n    } else if (dimension === 3) {\n      render3DLattice(false);\n    }\n  }, [dimension, basis, sumLimit, shadeParallelepiped, generateLatticePoints]);\n\n  const shadeRandomParallelepiped = () => {\n    const scene = sceneRef.current;\n    if (parallelepipedMesh) {\n      scene.remove(parallelepipedMesh);\n    }\n\n    const randomOffsets = Array.from({ length: dimension }, () => Math.floor(Math.random() * (2 * sumLimit + 1)) - sumLimit);\n    const parallelepipedVertices = [];\n\n    for (let i = 0; i < (1 << dimension); i++) {\n      const vertex = new Array(dimension).fill(0);\n      for (let j = 0; j < dimension; j++) {\n        vertex[j] = randomOffsets[j];\n        if (i & (1 << j)) {\n          for (let k = 0; k < dimension; k++) {\n            vertex[k] += basis[j][k];\n          }\n        }\n      }\n      parallelepipedVertices.push(...vertex.slice(0, 3)); \n    }\n\n    const parallelepipedGeometry = new THREE.BufferGeometry();\n    parallelepipedGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(parallelepipedVertices), 3));\n    const parallelepipedMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true });\n    const newParallelepipedMesh = new THREE.Mesh(parallelepipedGeometry, parallelepipedMaterial);\n    scene.add(newParallelepipedMesh);\n    setParallelepipedMesh(newParallelepipedMesh);\n  };\n\n  const handleDimensionChange = (e) => {\n    const newDimension = parseInt(e.target.value);\n    if (newDimension > 400) {\n      alert(\"Dimension cannot exceed 400\");\n      return;\n    }\n    setDimension(newDimension);\n    initializeBasis(newDimension);\n  };\n\n  const initializeBasis = (dim) => {\n    const newBasis = Array.from({ length: dim }, (_, i) => (\n      Array.from({ length: dim }, (_, j) => (i === j ? 1 : 0))\n    ));\n    setBasis(newBasis);\n  };\n\n  const handleBasisChange = (i, j, value) => {\n    const newBasis = basis.map((row, rowIndex) => (\n      row.map((col, colIndex) => (rowIndex === i && colIndex === j ? parseFloat(value) : col))\n    ));\n    setBasis(newBasis);\n  };\n\n  const handleShadeParallelepiped = () => {\n    shadeRandomParallelepiped();\n    setShadeParallelepiped(true);\n  };\n\n  const handleUnshadeParallelepiped = () => {\n    const scene = sceneRef.current;\n    if (parallelepipedMesh) {\n      scene.remove(parallelepipedMesh);\n      setParallelepipedMesh(null);\n      setShadeParallelepiped(false);\n    }\n  };\n\n  return (\n    <div>\n      <div>\n        <label>\n          Dimension:\n          <input type=\"number\" min=\"2\" max=\"400\" value={dimension} onChange={handleDimensionChange} />\n        </label>\n      </div>\n      <div>\n        <label>\n          Sum Limit:\n          <input type=\"number\" min=\"1\" max=\"10\" value={sumLimit} onChange={(e) => setSumLimit(parseInt(e.target.value))} />\n        </label>\n      </div>\n      <div>\n        <h3>Basis Vectors:</h3>\n        {basis.map((vector, i) => (\n          <div key={i}>\n            {vector.map((value, j) => (\n              <input\n                key={j}\n                type=\"number\"\n                value={value}\n                onChange={(e) => handleBasisChange(i, j, e.target.value)}\n                style={{ width: '50px', marginRight: '5px' }}\n              />\n            ))}\n          </div>\n        ))}\n      </div>\n      <button onClick={handleShadeParallelepiped}>Shade Parallelepiped</button>\n      <button onClick={handleUnshadeParallelepiped}>Unshade Parallelepiped</button>\n      {dimension <= 3 && (\n        <div style={{ width: '1024px', height: '768px' }}>\n          {dimension === 2 ? (\n            <svg ref={canvasRef}></svg>\n          ) : (\n            <canvas ref={canvasRef}></canvas>\n          )}\n        </div>\n      )}\n      {dimension > 3 && (\n        <div style={{ width: '1024px', height: '768px' }}>\n          <canvas ref={canvasRef}></canvas>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default LatticeVisualizer;\n\n\n\n\n\n\n\n","import React from 'react';\nimport LatticeVisualizer from './LatticeVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <LatticeVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport LatticeVisualizer from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <LatticeVisualizer />\n  </React.StrictMode>\n);\n"],"sourceRoot":""}